# ECharts Convert 插件 - 设计文档

## 1. 系统架构

### 1.1 整体架构

插件采用分层架构设计，从 Dify 平台调用到最终图表渲染，分为以下几个层次：

```
Dify Platform
    ↓
Plugin Entry (main.py)
    ↓
Provider Layer (provider/echarts-convert.py)
    ↓
Tool Layer (tools/echarts-convert.py)
    ↓
Utility Layer (tools/utils/)
    ↓
Executor Layer (js-executor/ 或 二进制执行器)
```

### 1.2 Tool 模块架构

Tool 层是插件的核心业务逻辑层，负责协调整个转换流程。其内部模块架构如下：

```
EchartsConvertTool
├── 参数处理模块
│   ├── 参数解析与验证
│   ├── 参数范围修正
│   └── JSON 配置解析
│
├── 文本解析模块 (parser.py)
│   ├── 代码块识别（正则匹配）
│   ├── JSON 配置提取
│   └── 错误标记
│
├── 渲染协调模块 (renderer.py)
│   ├── 执行器选择策略
│   ├── 命令构建
│   ├── 子进程管理
│   └── 结果解析
│
├── 二进制管理模块 (binary_manager.py)
│   ├── 版本化二进制查找
│   ├── 自动解压与缓存
│   └── 临时目录管理
│
├── 版本管理模块 (version_manager.py)
│   ├── 版本读取（从 manifest.yaml）
│   ├── 版本匹配策略
│   └── 旧版本清理
│
└── 结果处理模块
    ├── 图片 URL 生成
    ├── 文本替换
    └── 响应构建
```

## 2. 核心模块设计

### 2.1 文本解析模块 (parser.py)

**职责**：从文本中提取 ECharts 代码块并解析配置

**设计要点**：
- 使用正则表达式匹配 ````echarts` 代码块
- 对每个代码块进行 JSON 解析
- 记录代码块在原文中的位置信息
- 对解析失败的代码块标记错误信息，但不中断处理流程

**数据结构**：
- `EChartsBlock`: 表示一个代码块，包含原始文本、解析后的配置、位置信息、错误信息

### 2.2 渲染协调模块 (renderer.py)

**职责**：管理图表渲染的执行流程

**设计要点**：

#### 2.2.1 执行器选择策略
采用多级降级策略选择执行器：
1. 环境变量指定的本地调试执行器
2. 默认本地调试执行器（开发环境）
3. 版本化二进制执行器（生产环境，仅包含 Linux amd64 架构）
4. JavaScript 运行时（Bun，降级方案，需提前安装Bun）

**注意**：在生产环境的插件包中，只包含 Linux amd64 架构的二进制文件（受 50MB 插件包大小限制）。如果运行在 arm64 架构上，将降级到 JavaScript 运行时。

#### 2.2.2 命令构建
根据选择的执行器类型构建不同的命令：
- 二进制执行器：直接调用二进制文件
- 运行时执行器：通过 `bun run` 调用 TypeScript 脚本

#### 2.2.3 子进程通信
- 通过 stdin 传递 JSON 配置数组
- 通过 stdout 接收 JSON 格式的渲染结果

#### 2.2.4 结果解析
- 解析 JSON 格式的输出
- 提取 base64 编码的 SVG 数据
- 转换为二进制数据格式
- 构建 `RenderResult` 对象

### 2.3 二进制管理模块 (binary_manager.py)

**职责**：管理压缩二进制文件的解压和缓存

**设计要点**：

#### 2.3.1 版本化二进制管理
- 二进制文件名格式：`echarts-convert-{version}-linux-{arch}.gz`
- 支持多版本共存，运行时自动选择匹配版本
- 版本不匹配时自动选择最新可用版本

#### 2.3.2 自动解压策略
- 压缩文件存储在 `executables/` 目录
- 解压到临时目录（优先使用插件 tmp 目录，降级到系统 /tmp）
- 解压后的二进制文件设置可执行权限
- 已存在的二进制文件直接复用，避免重复解压

#### 2.3.3 临时目录管理
- 优先使用插件根目录下的 `tmp/` 目录
- 降级到系统 `/tmp/echarts-convert/` 目录
- 自动创建目录并验证读写权限

### 2.4 版本管理模块 (version_manager.py)

**职责**：管理插件版本和二进制版本匹配

**设计要点**：

#### 2.4.1 版本读取
- 从 `manifest.yaml` 读取当前插件版本
- 支持版本格式验证

#### 2.4.2 版本匹配策略
1. 优先匹配当前插件版本对应的二进制文件
2. 如果当前版本不存在，选择最新可用版本
3. 匹配成功后清理其他版本的二进制文件，节省存储空间

#### 2.4.3 版本清理
- 仅保留匹配的版本
- 清理其他版本的压缩文件
- 避免存储空间浪费

### 2.5 JavaScript 执行器架构 (js-executor/)

**职责**：执行实际的 ECharts 渲染工作

**设计要点**：

#### 2.5.1 主进程 (index.ts)
- 解析 CLI 参数（宽度、高度、并发数、合并选项）
- 从 stdin 读取 JSON 配置数组
- 协调并发渲染流程
- 输出 JSON 格式的渲染结果

#### 2.5.2 并发渲染策略
- 根据并发数将配置数组分片
- 为每个分片创建独立的 Worker 线程
- Worker 线程并行处理各自的分片
- 主进程收集所有结果并保持原始顺序

#### 2.5.3 Worker 线程 (worker.ts)
- 接收批量渲染任务
- 在独立线程中执行渲染
- 返回批量结果

#### 2.5.4 核心渲染函数 (render.ts)
- 初始化 ECharts 实例（SVG 渲染器）
- 应用配置合并（如果提供 mergeOptions）
- 渲染为 SVG 字符串
- 转换为 base64 编码的 data URL

## 3. 执行流程设计

### 3.1 主流程

```
1. 参数接收与验证
   ├── 解析工具参数
   ├── 验证参数范围
   └── 解析 JSON 配置（mergeEchartsOptions）

2. 代码块提取
   ├── 正则匹配代码块
   ├── JSON 解析
   └── 过滤有效配置

3. 渲染执行
   ├── 初始化渲染器
   ├── 选择执行器
   ├── 构建命令
   ├── 执行子进程
   └── 解析输出结果

4. 结果处理
   ├── 生成图片 URL
   ├── 创建 blob 消息
   └── 替换文本中的代码块

5. 响应构建
   ├── 生成更新后的文本
   ├── 构建摘要信息
   └── 按顺序输出消息
```

### 3.2 执行器选择流程

```
检查环境变量 (ECHARTS_CONVERT_LOCAL_PATH)
    ↓ (不存在)
检查默认本地调试执行器
    ↓ (不存在)
检查系统平台 (Linux)
    ↓ (是 Linux)
读取插件版本
    ↓
查找版本化二进制文件
    ↓ (找到)
解压到临时目录
    ↓
返回二进制路径
    ↓ (未找到或非 Linux)
降级到 JavaScript 运行时 (Bun)
```

### 3.3 并发渲染流程

```
接收配置数组
    ↓
判断并发数
    ↓ (并发数 <= 1)
顺序渲染
    ↓
返回结果
    ↓ (并发数 > 1)
计算 Worker 数量
    ↓
将配置数组分片
    ↓
为每个分片创建 Worker
    ↓
并行执行渲染
    ↓
收集所有结果
    ↓
按原始索引排序
    ↓
返回结果
```

## 4. 错误处理策略

### 4.1 分层错误处理

#### 4.1.1 参数层错误
- JSON 解析错误：抛出 `InvokeError`，包含明确的错误信息
- 参数范围错误：自动修正到有效范围，记录警告日志

#### 4.1.2 解析层错误
- 无效 JSON 配置：标记错误但不中断，继续处理其他代码块
- 无有效代码块：返回提示信息，不进行渲染

#### 4.1.3 渲染层错误
- 执行器未找到：抛出 `InvokeError`，提示安装或配置
- 子进程执行失败：捕获错误信息，返回给用户
- 超时：抛出超时错误，包含执行器类型信息

#### 4.1.4 结果处理错误
- 解析失败：标记为失败，记录错误信息
- 部分失败：成功部分正常返回，失败部分保持原样

### 4.2 降级策略

#### 4.2.1 执行器降级
- 生产环境优先使用二进制执行器
- 二进制不可用时降级到 JavaScript 运行时
- 开发环境允许使用本地调试执行器

#### 4.2.2 版本降级
- 当前版本二进制不存在时，自动选择最新可用版本
- 确保插件在版本不匹配时仍能正常工作

## 5. 数据流设计

### 5.1 输入数据流

```
Dify Platform
    ↓ (工具参数)
EchartsConvertTool._invoke()
    ↓ (参数字典)
参数处理模块
    ↓ (解析后的参数)
文本解析模块
    ↓ (EChartsBlock 列表)
渲染协调模块
    ↓ (JSON 配置数组)
JavaScript 执行器
```

### 5.2 输出数据流

```
JavaScript 执行器
    ↓ (JSON 结果数组)
渲染协调模块
    ↓ (RenderResult 列表)
结果处理模块
    ↓ (图片 URL、blob 消息)
响应构建模块
    ↓ (ToolInvokeMessage 序列)
Dify Platform
```

## 6. 部署架构

### 6.1 二进制打包策略

- 使用 Bun 将 TypeScript 代码编译为单个可执行二进制文件
- **打包限制**：由于 Dify 插件包（.difypkg）大小限制为 50MB，实际打包时仅包含 **Linux amd64** 架构的二进制文件
- 虽然架构设计上支持 Linux amd64 和 Linux arm64，但为了控制插件包体积，生产环境只打包 amd64 版本
- 按版本打包（`echarts-convert-{version}-linux-x64`）
- 使用 gzip 压缩，减小插件包体积
- 压缩文件存储在 `executables/` 目录
- 开发环境可通过 `INCLUDE_ARM64=true` 构建包含 arm64 的版本用于测试

### 6.2 运行时解压

- 首次使用时自动解压到临时目录
- 解压后的二进制文件可复用，避免重复解压
- 临时目录优先使用插件目录，确保权限和隔离性

### 6.3 版本管理

- 插件版本与二进制版本通过文件名关联
- 运行时自动匹配版本，支持版本降级
- 自动清理旧版本，节省存储空间

## 7. 设计决策说明

### 7.1 为什么使用 JavaScript 执行器？

- ECharts 是 JavaScript 库，在原生 JavaScript 环境中渲染最可靠
- 避免在 Python 中重新实现 ECharts 渲染逻辑
- 利用 ECharts 的 SSR（服务端渲染）能力

### 7.2 为什么采用二进制打包？

- 避免在生产环境依赖 Node.js/Bun 运行时
- 减小插件体积（单个二进制文件）
- 提高执行效率（无需解释执行）

### 7.5 为什么只打包 Linux amd64？

- **Dify 插件包限制**：.difypkg 文件大小不能超过 50MB
- 包含多个架构的二进制文件会显著增加插件包体积，可能超过限制
- Linux amd64 是最常见的服务器架构，覆盖大部分部署场景
- 如需支持其他架构，可在开发环境单独构建，但不包含在正式发布的插件包中

### 7.3 为什么支持并发渲染？

- 复杂图表渲染耗时较长，并发可以显著提升性能
- 利用多核 CPU 资源
- 通过 Worker 线程实现真正的并行处理

### 7.4 为什么采用版本化二进制管理？

- 支持插件版本升级时平滑过渡
- 允许不同版本的插件使用对应版本的二进制
- 避免版本不匹配导致的兼容性问题
